(* ::Package:: *)

(************************************************************************)\012(* This file was generated automatically by the Mathematica front end.  *)\012(* It contains Initialization cells from a Notebook file, which         *)\012(* typically will have the same name as this file except ending in      *)\012(* ".nb" instead of ".m".                                               *)\012(*                                                                      *)\012(* This file is intended to be loaded into the Mathematica kernel using *)\012(* the package loading commands Get or Needs.  Doing so is equivalent   *)\012(* to using the Evaluate Initialization Cells menu command in the front *)\012(* end.                                                                 *)\012(*                                                                      *)\012(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)\012(* automatically each time the parent Notebook file is saved in the     *)\012(* Mathematica front end.  Any changes you make to this file will be    *)\012(* overwritten.                                                         *)\012(************************************************************************)\012\012

UnitForm[units_][quantity_]:=UnitConvert[quantity,units]
UnitForm::usage="like UnitConvert but for postfix";


(* ::Input::Initialization:: *)
(* Make it so you can always UnitForm 0 into any units *)
(*UnitConvert[zero_?(#==0&),targetunit_]^:=Quantity[0,targetunit]*)
(*UnitConvert[0.,targetunit_]^:=Quantity[0,targetunit]*)


Subscript[s_String, q]:=Quantity[s]


ClearAll@loadQuantities;
quantityAssoc[HoldPattern@symb]:=<|\[HBar]->Quantity["ReducedPlanckConstant"]|>[symb]
(* Makes loadQuantities idempotent, so loadQuantities[loadQuantities[\[HBar]]]==loadQuantities[\[HBar]] *)
loadQuantities[q_Quantity]:=q;
(* Define constants that can be loaded *)
loadQuantities[HoldPattern@\[HBar]]:=\[HBar]=Quantity["ReducedPlanckConstant"];
loadQuantities[HoldPattern[h]]:=h=Quantity["PlanckConstant"];
loadQuantities[HoldPattern@c]:=c=Quantity["SpeedOfLight"];
loadQuantities[HoldPattern@Subscript[q, e]]:=Subscript[q, e]=Quantity["ElectronCharge"];
loadQuantities[HoldPattern@Subscript[m, e]]:=Subscript[m, e]=Quantity["ElectronMass"];
loadQuantities[HoldPattern@Subscript[m, p]]:=Subscript[m, p]=Quantity["ProtonMass"];
loadQuantities[HoldPattern@Subscript[m, n]]:=Subscript[m, n]=Quantity["NeutronMass"];
loadQuantities[HoldPattern@Subscript[m, \[Mu]]]:=Subscript[m, \[Mu]]=Quantity["MuonMass"];
loadQuantities[HoldPattern@Subscript[m, \[Tau]]]:=Subscript[m, \[Tau]]=Quantity["TauMass"];
loadQuantities[HoldPattern@Subscript[\[Epsilon], 0]]:=Subscript[\[Epsilon], 0]=Quantity["VacuumPermittivity"];
loadQuantities[HoldPattern@Subscript[\[Mu], 0]]:=Subscript[\[Mu], 0]=Quantity["VacuumPermeability"];
loadQuantities[HoldPattern@Subscript[a, 0]]:=Subscript[a, 0]=Quantity["BohrRadius"];
loadQuantities[HoldPattern@G]:=G=Quantity["GravitationalConstant"];
loadQuantities[HoldPattern@Subscript[N, A]]:=Subscript[N, A]=Quantity["AvogadroConstant"];
loadQuantities[HoldPattern@Subscript[k, B]]:=Subscript[k, B]=Quantity["BoltzmannConstant"];
(* Allow list of quantities to be loaded  *)
SetAttributes[loadQuantities,Listable]
(*(* Handle other symbols not defined above, and return 0 *)
loadQuantities::unknownSymb="Unknown symbol `1`";
loadQuantities[symb_]:=(Message[loadQuantities::unknownSymb,symb];symb);*)
(* Return unknown symbols unchanged *)
loadQuantities[symb_]:=symb;
(* Load product, sum, etc of constants at once *)
loadQuantities[HoldPattern[f_[symbs__]]]:=f@@loadQuantities[{symbs}]
(* Allow list of quantities to be loaded without surrounding in brackets *)
loadQuantities[symbs__]:=loadQuantities[{symbs}]
(* With no arguments, load all quantities *)
(* todo figure out how to not have to hardcode the -5 (# of non-definition defs) *)
loadQuantities[]:=(Keys[DownValues[loadQuantities]]/.loadQuantities->List)[[;;-5,1]]//Flatten//ReleaseHold//loadQuantities


also[f_][x_]:=(f@x;x)


alsoPrint[f_:Identity]:=also[Print@*f]


saveDirectory[]:=Module[
	{dir=FileNameJoin@{NotebookDirectory[],"mathematica_figures"}},
	If[
		!DirectoryQ@dir,
		CreateDirectory[FileNameJoin@{NotebookDirectory[],"mathematica_figures"}],
		dir
	]
]
save[fig_,name_String,format_String:"pdf",dpi_Integer:500]:=Export[FileNameJoin@{saveDirectory[],name<>"."<>format},fig,ImageResolution->dpi]
save[fig_,name_String,formats_List,dpi_Integer:500]:=save[fig,name,#,dpi]&/@formats
alsoSave[name_String,format_String:"pdf",dpi_Integer:500]:=also[save[#,name,format,dpi]&]
alsoSave[name_String,formats_List,dpi_Integer:500]:=also[save[#,name,formats,dpi]&]


alsoCopyOpts[opts___]:=also[CopyToClipboard@Rasterize[#,opts]&];
alsoCopy=alsoCopyOpts[]


tableHeaded[headers_][list_]:=TableForm[list,TableHeadings->headers]
tableHeadedRows[rows_][list_]:=TableForm[list,TableHeadings->{rows,None}]
tableHeadedCols[cols_][list_]:=TableForm[list,TableHeadings->{None,cols}]


defaultColorData[]:=ColorData[97]
defaultColorData[n_Integer]:=defaultColorData[][n]


(* Pride Flags! *)
(* How to add gradients: https://mathematica.stackexchange.com/questions/57885/is-it-possible-to-insert-new-colour-schemes-into-colordata/57893#57893 *)
(* Flag rgb colors: https://www.flagcolorcodes.com/flags/pride *)

ColorData[1];
(* Export this function so users can add gradients as needed *)
insertGradient[name_,gradColors_]:=If[
	!MemberQ[ColorData["Gradients"],name],
	(
		AppendTo[
			DataPaclets`ColorDataDump`colorSchemes,
			{{name,"",{}},{"Gradients"},1,{0,1},gradColors,""}
		];
		AppendTo[
			DataPaclets`ColorDataDump`colorSchemeNames,
			name
		];
	)
]
Module[{data,names,colors},
	data=Import["https://raw.githubusercontent.com/Annie-Schwartz/YouTilities/master/flags.tsv","TSV","Numeric"->False];
	names=#<>"Flag"&/@data[[;;,1]];
	colors=Map[RGBColor["#"<>#]&,data[[;;,2;;]],{2}];
	
	insertGradient@@#&/@Transpose@{names,colors};
]


(* ::Input::Initialization:: *)
EigvecsT[A_,neigs_:"all",\[CapitalDelta]_:Automatic]:=Transpose@Eigvecs[A,neigs,\[CapitalDelta]]
EigsysT[A_,neigs_:"all",\[CapitalDelta]_:Automatic]:=MapThread[#1@#2&,{{Identity,Transpose},Eigsys[A,neigs,\[CapitalDelta]]}]


(* Exponentiate with something other than Times (useful for matrix powers with Dot) *)
Subscript/:Power[Subscript[mat_,mp],n_]:=MatrixPower[mat,n]
Subscript/:Power[Subscript[mat_,Dot],n_]:=MatrixPower[mat,n]


ClearAll@eigenStuff
eigenStuff::zeroEigenvectors="Some zero-eigenvectors";
eigenStuff::unequal="#vals!=#vecs";
eigenStuff[matrix_,opts:OptionsPattern[{sys->Eigensystem,ai\[Lambda]->False,rref->False,normalize->False}]]:=Module[
	{
		ai\[Lambda]=OptionValue@ai\[Lambda],
		rref=OptionValue@rref,
		normalize=OptionValue@normalize,
		sys=OptionValue@sys,
		len=Length@matrix,
		vecs,vals
	},
	{vals,vecs}=sys[matrix];
	vecs=If[normalize,Normalize/@vecs,vecs];
	If[ContainsAny[vecs,{Table[0,len]}],
		Throw[Message[eigenStuff::zeroEigenvectors]]
	];
	AI\[Lambda]=matrix-# IdentityMatrix@len&/@vals//Simplify;
	If[Length/@{vals,vecs}/.List->Equal,
		Grid[
			Join[
				{{"\[Lambda]",If[ai\[Lambda],"A-I\[Lambda]",Nothing],If[rref,"RREF",Nothing],"Eigenvector"}},
				{
					vals,
					If[ai\[Lambda],MatrixForm/@AI\[Lambda],Nothing],
					If[rref,MatrixForm@*RowReduce/@AI\[Lambda],Nothing],
					MatrixForm/@vecs
				}\[Transpose]
			],
			Frame->All
		],
		Message[eigenStuff::unequal]
	]
]


(* ::Input::Initialization:: *)
CirclePlus[mat_?MatrixQ,hc]:=mat+mat\[ConjugateTranspose]
CirclePlus[val_,cc]:=val+val\[Conjugate]


(* ::Input::Initialization:: *)
LoadBra[]:=(
Bra[{labels__}]:=Ket[{labels}]\[Conjugate];
BraKet[{a__},{b__}]:=Bra[{a}]\[Conjugate] . Ket[{b}];
)


(* ::Input::Initialization:: *)
LoadArbitrarySpinMatricesJ[S_,type_:"n",chain_:1]:=If[Length@DownValues@LoadArbitrarySpinMatrices==0,
"Please make sure to load Melt before running LoadArbitrarySpinMatricesJ!",
(*{J0,Jx,Jy,Jz,Jp,Jm,\[ScriptCapitalJ]x,\[ScriptCapitalJ]y,\[ScriptCapitalJ]z,\[ScriptCapitalJ]p,\[ScriptCapitalJ]m}=Eat[{S0,Sx,Sy,Sz,Sp,Sm,\[ScriptCapitalS]x,\[ScriptCapitalS]y,\[ScriptCapitalS]z,\[ScriptCapitalS]p,\[ScriptCapitalS]m},LoadArbitrarySpinMatrices[S,type,chain]];*)
Block[{S0,Sx,Sy,Sz,Sp,Sm,\[ScriptCapitalS]x,\[ScriptCapitalS]y,\[ScriptCapitalS]z,\[ScriptCapitalS]p,\[ScriptCapitalS]m},
ClearAll[J0,Jx,Jy,Jz,Jp,Jm];
LoadArbitrarySpinMatrices[S,type,chain];
J0=S0;Jx=Sx;Jy=Sy;Jz=Sz;Jp=Sp;Jm=Sm;
If[chain===1,
"Matrices loaded: J0 (=1), Jx, Jy, Jz, Jp, Jm",
\[ScriptCapitalJ]0=\[ScriptCapitalS]0;\[ScriptCapitalJ]x=\[ScriptCapitalS]x;\[ScriptCapitalJ]y=\[ScriptCapitalS]y;\[ScriptCapitalJ]z=\[ScriptCapitalS]z;\[ScriptCapitalJ]p=\[ScriptCapitalS]p;\[ScriptCapitalJ]m=\[ScriptCapitalS]m;"Matrices loaded: \[ScriptCapitalJ]0 (=1), \[ScriptCapitalJ]x, \[ScriptCapitalJ]y, \[ScriptCapitalJ]z, \[ScriptCapitalJ]p, \[ScriptCapitalJ]m"
]
]
]


(* ::Input::Initialization:: *)
ClearAll[BlockDiagonalizer]
BlockDiagonalizer[ops__]:=Module[{os=Reverse@{ops},U},
U=BlockDiagonalizer@First@os;
Do[
U=U . BlockDiagonalizer[Inverse[U] . os[[idx]] . U],
{idx,2,Length@os}
];
U
]
BlockDiagonalizer[op_]:=LocalizeAll[{},{},
{\[Lambda]s,vs}=Eigensystem@op;
Transpose@vs[[Ordering[\[Lambda]s,All,Greater]]]
]
(*BlockDiagonalizer[op_]:=LocalizeAll[{},{},
{\[Lambda]s,vs}=Eigensystem@op;
evals=Sort[DeleteDuplicates@\[Lambda]s,Greater];
Transpose@flat1@Table[
Normalize/@vs[[Flatten@Position[\[Lambda]s,\[Lambda]]]],
{\[Lambda],evals}
]
]*)


(* ::Input::Initialization:: *)
ClearAll[BlockEigvals]
BlockEigvals[U_]:=With[{Ui=Inverse@U},
Eigvals[Ui . # . U]&
]
(*BlockEigvals[mat_,U_]:=With[{Ui=Inverse@U},
Eigvals[Ui.mat.U]
]*)
(*BlockEigvals2[mat_,U_]:=With[{Ui=Inverse@U},
Eigvals[BlockDiagonalMatrix[Ui.mat.U]]
]*)


(* ::Input::Initialization:: *)
ClearAll[PrePrintMatrixForm]
PrePrintMatrixForm=If[MatrixQ@#,MatrixForm@#,#]&;


ClearAll[enumerate]
enumerate=MapIndexed[{#2[[1]],#1}&];


(* https://mathematica.stackexchange.com/a/154287 *)
SparseReplaceAll[s_SparseArray,rule_]:=With[{
		elems=ReplaceAll[s["NonzeroValues"],rule],
		default=ReplaceAll[s["Background"],rule]
	},
	SparseArray[
		Automatic,
		s["Dimensions"],
		default,
		{1,{s["RowPointers"],s["ColumnIndices"]},elems}
	]
]


Charting$InteractiveHighlighting=False;


(* ::Input::Initialization:: *)
Subscript[l_List,seq]:=Sequence@@l


(* ::Input::Initialization:: *)
ClearAll[Benchmark]
Benchmark[fns_List,ns_List,nToInput_,OptionsPattern[{RefImpl->1,CorrectTest->None}]]:=Transpose@table[
With[{input=nToInput@n},
Table[{n,RepeatedTiming[fn@nToInput@n][[1]]},{fn,fns}]
],
{n,ns}
]


(* ::Input::Initialization:: *)
Subscript[s_String,sf][exprs__]:=StringForm[s,exprs]
Subscript[s_String,st]:=StringTemplate[s]


StringPrepend[rest_,pre_]:=pre<>ToString@rest
StringPrepend[pre_][rest_]:=StringPrepend[rest,pre]

StringAppend[rest_,app_]:=ToString@rest<>app
StringAppend[app_][rest_]:=StingAppend[rest,app]


(* ::Input::Initialization:: *)
ClearAll[Eat]
SetAttributes[Eat,HoldAll]
Eat[symbs_List,body_]:=Block[symbs,body;symbs]


(* ::Input::Initialization:: *)
ClearAll[WithWith]
SetAttributes[WithWith,HoldAll]
WithWith[list_List,body_]:=Fold[
ReplaceAll[{Hold[hinner_],Hold[hvar_]}->Hold@With[{hvar},hinner]]@*List,
Hold@body,
Reverse@First@Map[Hold,Hold@list,{2}]
]//ReleaseHold


(* ::Input::Initialization:: *)
ClearAll[LocalizeAll];
SetAttributes[LocalizeAll,HoldAll];
LocalizeAll[code_]:=LocalizeAll[{},{},code]
LocalizeAll[extra_List,code_]:=LocalizeAll[extra,{},code]
LocalizeAll[extra_List,except_List,code_]:=Module[{expressions,locals},
expressions=List@@Map[Hold,Hold[code]/.CompoundExpression->List,{2}][[1]];
(*Echo[FullForm@expressions];
Echo[Hold@@Hold[except][[;;]]];*)
locals=Complement[
Join@@Join[
(* lhs=rhs *)
Cases[expressions,
Hold[Set[lhs_,rhs_]]:>Switch[Hold[lhs],
(* {lhs1,lhs2,...}=rhs *)
Hold[_List],Sequence@@Map[Hold,Hold[lhs],{2}][[1]],
(* lhs[[vars]]=lhs *)
Hold[_Part],Hold@@Map[Hold,Hold[lhs],{2}][[1,1]],
(* lhs=rhs *)
_,Hold[lhs]
]
],
(* lhs[vars]:=rhs  TODO: do I also need a Set (not Delayed) for this? *)
Cases[expressions,Hold[SetDelayed[lhs_[vars___],rhs_]]:>Hold@lhs],
(*(* TODO! lhs[[vars]]=lhs *)
Cases[expressions,Hold[Set[lhs_[[vars___]],rhs_]]:>Hold@lhs],*)
(* any extras :) *)
Hold/@extra
],
Hold@@except
]/.Hold[locals__]:>Hold[{locals}];
(*Echo@locals;*)
Module@@Hold[Evaluate[Unevaluated@@locals],code]
]



